<?xml version="1.0" encoding="UTF-8"?>
<xsearch-web>
  <analyzers>
    <analyzer name="Synonym Algorithm">
      <class>com.fdt.sdl.core.analyzer.synonym.SynonymAlgorithm</class>
      <description>Synonyms</description>
      <language>Any</language>
    </analyzer>
    <analyzer name="Alpha Numeric Algorithm">
      <class>com.fdt.sdl.core.analyzer.AlphaNumericAnalyzer</class>
      <description>Alphanumeric algorithm that strips all the special characters and spaces</description>
      <language>Any</language>
    </analyzer>
    <analyzer name="Number or LowerCase(Recommended) Algorithm">
      <class>com.fdt.sdl.core.analyzer.NumberLowerCaseAnalyzer</class>
      <description>Analyze mumbers or lowercase words</description>
      <language>Any</language>
    </analyzer>
    <analyzer name="One Word, Number or LowerCase Algorithm">
      <class>com.fdt.sdl.core.analyzer.OneWordNumberLowerCaseAnalyzer</class>
      <description>
        Analyze mumber or lowercase words, but also keep a word that's connected by non-letter characters remaining as one word.
        For example, "I.B.M." => "ibm", "M-234" => "m234".
        So later search, "ibm", "I.B.M", or "M234", can find the intended matches.
      </description>
      <language>Any</language>
    </analyzer>
    <analyzer name="Keyword Case Insensitive Alpha Numeric Algorithm">
      <class>com.fdt.sdl.core.analyzer.KeywordCaseInsensitiveAlphNumericAnalyzer</class>
      <description>Removes the Special Characters in Keyword Case Insensitive</description>
      <language>Any</language>
    </analyzer>
    <analyzer name="Whitespace Algorithm">
      <class>org.apache.lucene.analysis.WhitespaceAnalyzer</class>
      <description>Separate keywords by whitespace</description>
      <language>Any</language>
    </analyzer>
    <analyzer name="Comma-Semicolon Algorithm">
      <class>com.fdt.sdl.core.analyzer.CommaSemicolonAnalyzer</class>
      <description>Separate keywords by comma or semicolon, and lowercase them. Mostly for tags, especially good for tag clouds.</description>
      <language>Any</language>
    </analyzer>
    <analyzer name="Double Metaphone Algorithm">
      <class>com.fdt.sdl.core.analyzer.DoubleMetaphoneAnalyzer</class>
      <description>Similar to metaphone analyzer, more accurate.</description>
      <language>English,Germany,Bengali, Hindi, Gujarati, Kannada, Malayalam, Tamil, Telugu, etc</language>
    </analyzer>
    <analyzer name="Date Algorithm">
      <class>com.fdt.sdl.core.analyzer.DateAnalyzer</class>
      <description>Date analyzer for analyzing dates</description>
      <language>English</language>
    </analyzer>
  </analyzers>

  <similarities>
    <similarity name="Default">
      <class>org.apache.lucene.search.DefaultSimilarity</class>
      <description>Default implementation. Check javadoc for org.apache.lucene.search.DefaultSimilarity</description>
    </similarity>
    <similarity name="Avoid Length Normalization">
      <class>net.javacoding.xsearch.search.FairSimilarity</class>
      <description>
        By overriding lengthNorm, it is possible to discount how the length of a field contributes to a score. 
        In DefaultSimilarity, lengthNorm = 1 / (numTerms in field)^0.5, 
        but if one changes this to be 1 / (numTerms in field), all fields will be treated "fairly".
      </description>
    </similarity>
  </similarities>

  <column-classes>
    <column-class name="String">
      <value>java.lang.String</value>
    </column-class>
    <column-class name="Number(Integer,Float)">
      <value>java.math.BigDecimal</value>
    </column-class>
    <column-class name="Time,Date">
      <value>java.sql.Timestamp</value>
    </column-class>
    <column-class name="Clob(java.sql.Clob)">
      <value>java.sql.Clob</value>
    </column-class>
    <column-class name="Blob(java.sql.Blob)">
      <value>java.sql.Blob</value>
    </column-class>
  </column-classes>

  <index-field-types>
    <index-field-type name="Keyword">
      <value>Keyword</value>
    </index-field-type>
    <index-field-type name="Text">
      <value>Text</value>
    </index-field-type>
    <index-field-type name="Hierachical Date">
      <value>KeywordDateHierarchical</value>
    </index-field-type>
    <index-field-type name="UnIndexed">
      <value>UnIndexed</value>
    </index-field-type>
    <index-field-type name="Keyword + Boost Factor">
      <value>KeywordBoost</value>
    </index-field-type>
    <index-field-type name="Keywords">
      <value>Keywords</value>
    </index-field-type>
    <index-field-type name="Keyword Case Insensitive">
      <value>KeywordCaseInsensitive</value>
    </index-field-type>
    <index-field-type name="Only as Boost Factor">
      <value>Boost</value>
    </index-field-type>
  </index-field-types>

  <wizard name="Get Data, Search, Display">
    <step name="Configure Index Directory">
      <action>configBasic,createIndex</action>
      <repeatable>true</repeatable>
      <description><![CDATA[Set the directory to store the index]]></description>
    </step>
    <step name="Connect to Data Source">
      <action>configDataSource,configConnection,configFetcher</action>
      <repeatable>true</repeatable>
      <description><![CDATA[Setup and test data source]]></description>
    </step>
    <step name="Get Documents">
      <action>configDataSelect,configWorkingQueue,configContent,configFetchResult</action>
      <repeatable>true</repeatable>
      <description><![CDATA[Get all documents, or just the list]]></description>
    </step>
    <step name="Select a display template">
      <action>listScaffolds,createTemplate</action>
      <repeatable>true</repeatable>
      <description><![CDATA[Choose one template and match corresponding columns]]></description>
    </step>
    <step name="Schedule Data Retrieval">
      <action>listSchedules,configSchedule</action>
      <repeatable>true</repeatable>
      <description><![CDATA[Choose repeat interval or a cron style schedule]]></description>
    </step>
  </wizard>

  <date-formats>
    <date-format>M/d/yyyy h:mm a</date-format>
    <date-format>M/d/yyyy hh:mm:ss a</date-format>
    <date-format>M/d/yyyy</date-format>
    <date-format>h:mm a</date-format>
    <date-format>h:mm a z</date-format>
    <date-format>h:mm a, MMMMM dd, yyyy</date-format>
    <date-format>h:mm:ss a</date-format>
    <date-format>HH:mm</date-format>
    <date-format>MMM dd, yyyy</date-format>
    <date-format>MMMMM dd, yyyy</date-format>
    <date-format>MMMMM dd, yyyy h:mm a</date-format>
    <date-format>EEEEE, MMMMM dd, yyyy</date-format>
    <date-format>EEEEE, MMMMM dd, yyyy h:mm:ss a</date-format>
    <date-format>EEE MMM dd, hh:mm:ss a z</date-format>
    <date-format>EEE MMM dd, hh:mm:ss a</date-format>
    <date-format>EEE MMM dd, hh:mm:ss a yyyy</date-format>
    <date-format>EEE, d MMM yyyy hh:mm:ss z</date-format>
    <date-format>d.M.yy</date-format>
    <date-format>d/M/yy</date-format>
    <date-format>d/M/yy HH:mm</date-format>
    <date-format>d/M/yy h:mm a</date-format>
    <date-format>EEEEE, dd MMMMM, yyyy</date-format>
    <date-format>dd MMMMM, yyyy HH:mm</date-format>
    <date-format>dd MMMMM, yyyy</date-format>
    <date-format>yyyy-MM-dd</date-format>
    <date-format>yyyy-MM-dd HH:mm</date-format>
    <date-format>yyyy-MM-dd HH:mm:ss z</date-format>
    <date-format>yyyy/MM/dd HH:mm:ss z</date-format>
  </date-formats>

  <number-formats>
    <number-format>0</number-format>
    <number-format>#,##0</number-format>
    <number-format>#,##0.##</number-format>
    <number-format>$#,##0.##</number-format>
  </number-formats>

  <commands>
    <command name="Incremental Indexing">
      stopIndexing unlockStoppedIndex createPeriodTable
      maybeBuildSynonyms incrementalIndexingWithoutDeletion
      mergeIndexesIfNeeded
      buildDictionaryIfNeeded ping-a-url
    </command>
    <command name="Incremental Indexing with Fast Deletion Detection">
      stopIndexing unlockStoppedIndex createPeriodTable
      maybeBuildSynonyms incrementalIndexingWithFastDeletion
      mergeIndexesIfNeeded
      buildDictionaryIfNeeded ping-a-url
    </command>
    <command name="Incremental Indexing with Thorough Deletion Detection">
      stopIndexing unlockStoppedIndex createPeriodTable
      maybeBuildSynonyms incrementalIndexingWithThoroughDeletion
      mergeIndexesIfNeeded
      buildDictionaryIfNeeded ping-a-url
    </command>
    <command name="Incremental Indexing,Fast Deletion Detection,Spell Check Index">
      stopIndexing unlockStoppedIndex createPeriodTable
      maybeBuildSynonyms incrementalIndexingWithFastDeletion
      mergeIndexesIfNeeded
      buildDictionaryIfNeeded ping-a-url
    </command>
    <command name="Re-create Index">
      stopIndexing unlockStoppedIndex
      maybeBuildSynonyms reCreateIndex
      mergeIndexes
      reBuildDictionary
      buildDictionaryIfNeeded ping-a-url
    </command>
    <command name="Subscribe Index">
        inMemory stopIndexing unlockStoppedIndex
        retrieveSubscription
        ping-a-url
    </command>
    <command name="Re-create Spelling Dictionary">unlockStoppedIndex reBuildDictionary</command>
    <command name="Refresh Index">refreshIndex</command>
  </commands>

</xsearch-web>